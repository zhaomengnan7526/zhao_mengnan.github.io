---
layout:     post
title:      "iOS开发中的锁"
subtitle:   "介绍了iOS开发中常用的锁，以及用法、原理等"
date:       2017-11-30 17:38:00
author:     "赵梦楠"
header-img: "img/post-bg-hacker.jpg"
catalog: true
tags:
    - iOS
    - 多线程
---


# iOS开发中的锁

## 前言
在多线程开发中，常会遇到多个线程访问修改数据。为了防止数据不一致或数据污染，通常采用加锁机制来保证线程安全。

## 概述
锁是多线程开发中最基本的同步工具。开发中常用的锁通常分为以下几种类型：

- **Mutex(互斥锁)**: 互斥锁是一种信号量，一次只能访问一个线程如果一个互斥体正在使用，而另一个线程试图获取它，则该线程将阻塞，直到互斥体被其原始持有者释放。如果多个线程竞争同一个互斥体。则一次只允许一个线程访问它。

- **Recursive lock(递归锁)**：递归锁是互斥锁的变体。递归锁允许单个线程在释放之前多次获取锁。其他线程保持阻塞状态。直到锁的所有者释放锁的次数与获取它的次数相同，递归锁主要在递归中使用，但也可能在多个方法需要单独获取锁的情况下使用。

- **Spin lock(自旋锁)**: 自旋锁重复其锁定条件，直到该条件成立。自旋锁最常用于多处理器系统，其中锁的预期等待时间很短。在这些情况下，轮询通常比阻塞线程更高效，这涉及到上下文切换和线程数据结构的更新。

- **Read-write lock(读写锁)**：读写锁也被称为*Shared-exclusive lock*。通常用于较大规模的操作，适用于数据结构被频繁读取和偶尔修改，可以显着提高性能。在正常操作期间，多个线程可以同时访问数据。当一个线程想要写入数据时会阻塞，直到所有的读取线程释放锁。此时，写入线程才能获取锁，并修给数据。写入线程在锁定时，新的线程将被阻塞，直到写入线程完成。

- **Distributed lock(分布式锁)**: 分布式锁提供进程级别的互斥访问。与真正的互斥锁不同，分布式锁不会阻塞进程或阻止进程运行。它只是报告锁何时忙，让流程决定如何进行。


- **Double-checked lock(双重检查锁)**: 双重检查锁试图通过在锁定之前测试锁定标准来降低锁定的开销。由于双重检查的锁可能是不安全的，系统不提供对它们的明确的支持，并且它们的使用是不鼓励的。

以上大致介绍了锁的分类，下面将介绍`Objective-C`中各种锁的实现。

## 一、@synchronized指令

### 简介
`@synchronized`指令是`Objective-C`中易用性和可读性最好的创建互斥锁的方式。我们不用去直接创建锁和锁定对象，它会像其它互斥锁一样，防止其它线程获取同一个锁。传递给`@synchronized`的对象是区分保护块的唯一标识。它的简单用法是这样

``` 
- （void）myMethod：（id）anObj
{
    @synchronized（anObj）
    {
        //需要加锁的内容
    }
}
```

### 实现原理
编译器将`@synchronized`转化成了一对`objc_sync_enter()`和`objc_sync_exit()`的调用，通过查看[源码](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm)我们可以分析得出：

- `@synchronized`是通过`recursive_mutex_t `递归锁实现；
- `@synchronized（object)`中传入的object的内存地址，被用作唯一的key，通过hash map对应到一个系统维护的递归锁；
- `objc_sync_enter()`和`objc_sync_exit()`并没有对传入的对象做`retains`和`releases`;
- `objc_sync_enter(nil)`和`objc_sync_exit(nil)`不起任何作用；

详细的分析可以参见这篇博客：[正确使用多线程同步锁@synchronized()](https://zhuanlan.zhihu.com/p/24082524)。

### 使用注意
通过上面的分析， 我们可以得出`@synchronized`使用中应该注意的几个问题

- 因为`@synchronized`使用递归锁实现的，所以如下代码不会产生死锁；

```
@synchronized (obj) {
    NSLog(@"1st sync");
    @synchronized (obj) {
        NSLog(@"2nd sync");
    }
}
```

- 因为是利用传入的`object`的内存地址作为唯一标识，所以传入的`object`理论上可以是任意对象，但应避免不同的critical section使用相同的锁，应该是不同的数据使用不同的锁；

```
@synchronized (objectA) {
    [arrA addObject:obj];
}

@synchronized (objectB) {
    [arrB addObject:obj];
}
```

- 应该注意传入对象的生命周期，因为`@synchronized（object）`并没有对object进行`retains`，因此当`@synchronized（nil）`时，将不起任何作用；

- 注意`@synchronized（object）`内部的方法调用，将不需要同步操作的方法放在外面调用；

- 另外官方文档中提到 :
> 作为预防措施，`@synchronized`块隐式地向受保护的代码添加异常处理程序。如果引发异常，该处理程序会自动释放互斥锁。这意味着为了使用`@synchronized`指令，还必须在代码中启用`Objective-C`异常处理。如果您不想由隐式异常处理程序引起额外开销，则应考虑使用锁类。



## 二、NSLock

### 简介
`NSLock`是典型的面向对象的锁，即同步锁类，遵循`Objective-C`的`NSLocking`协议接口，该协议定义了`lock`和`unlock`。此外`NSLock`类还增加了`tryLock` 和 `lockBeforeDate:`方法。`tryLock`方法尝试获取锁，如果锁不可用返回`NO`。`lockBeforeDate:`尝试在指定时间内获取锁，如不成功返回`NO`。

```
    NSLock *lock = [[NSLock alloc] init];
    //线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程1 准备加锁ing...");
        [lock lock];
        NSLog(@"线程1 锁定成功");
        sleep(5);//睡眠5秒
        NSLog(@"线程1 准备解锁");
        [lock unlock];
        NSLog(@"线程1 解锁成功");
    });
    
    //线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@"线程2 尝试加锁ing...");
        BOOL x =  [lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:4]];
        if (x) {
            NSLog(@"线程2 锁定成功");
            [lock unlock];
            NSLog(@"线程2 解锁成功");
        }else{
            NSLog(@"线程2 加锁失败");
        }
    });
```
### 实现原理

`NSLock`是在内部封装了一个 `pthread_mutex`，属性为`PTHREAD_MUTEX_ERRORCHECK`，它会损失一定性能换来错误提示。

### 使用注意

- 向`NSLock`对象发送解锁消息时，必须确保该消息是从发送初始锁定消息的同一线程发送的。解锁来自不同线程的锁可能会导致未定义的行为。
- 在同一线程上两次调用`lock`方法，会造成死锁，一次在递归中不能使用`NSLock`。可使用`NSRecursiveLock`。



