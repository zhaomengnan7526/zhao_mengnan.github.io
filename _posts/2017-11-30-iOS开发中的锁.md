---
layout:     post
title:      "iOS开发中的锁"
subtitle:   "介绍了iOS开发中常用的锁，以及用法、原理等"
date:       2017-11-30 17:38:00
author:     "赵梦楠"
header-img: "img/post-bg-hacker.jpg"
catalog: true
tags:
    - iOS
    - 多线程
---


#iOS开发中的锁
##前言
在多线程开发中，常会遇到多个线程访问修改数据。为了防止数据不一致或数据污染，通常采用加锁机制来保证线程安全。
##概述
锁是多线程开发中最基本的同步工具。开发中常用的锁通常分为以下几种类型：

- **Mutex(互斥锁)**: 互斥锁是一种信号量，一次只能访问一个线程如果一个互斥体正在使用，而另一个线程试图获取它，则该线程将阻塞，直到互斥体被其原始持有者释放。如果多个线程竞争同一个互斥体。则一次只允许一个线程访问它。

- **Recursive lock(递归锁)**：递归锁是互斥锁的变体。递归锁允许单个线程在释放之前多次获取锁。其他线程保持阻塞状态。直到锁的所有者释放锁的次数与获取它的次数相同，递归锁主要在递归中使用，但也可能在多个方法需要单独获取锁的情况下使用。

- **Spin lock(自旋锁)**: 自旋锁重复其锁定条件，直到该条件成立。自旋锁最常用于多处理器系统，其中锁的预期等待时间很短。在这些情况下，轮询通常比阻塞线程更高效，这涉及到上下文切换和线程数据结构的更新。

- **Read-write lock(读写锁)**：读写锁也被称为*Shared-exclusive lock*。通常用于较大规模的操作，适用于数据结构被频繁读取和偶尔修改，可以显着提高性能。在正常操作期间，多个线程可以同时访问数据。当一个线程想要写入数据时会阻塞，直到所有的读取线程释放锁。此时，写入线程才能获取锁，并修给数据。写入线程在锁定时，新的线程将被阻塞，直到写入线程完成。

- **Distributed lock(分布式锁)**: 分布式锁提供进程级别的互斥访问。与真正的互斥锁不同，分布式锁不会阻塞进程或阻止进程运行。它只是报告锁何时忙，让流程决定如何进行。


- **Double-checked lock(双重检查锁)**: 双重检查锁试图通过在锁定之前测试锁定标准来降低锁定的开销。由于双重检查的锁可能是不安全的，系统不提供对它们的明确的支持，并且它们的使用是不鼓励的。

以上大致介绍了锁的分类，下面将介绍`Objective-C`中各种锁的实现。

##一、@synchronized指令
`@synchronized`指令是`Objective-C`中易用性和可读性最好的创建互斥锁的方式。它的简单用法是这样

``` 
- （void）myMethod：（id）anObj
{
    @synchronized（anObj）
    {
        //需要加锁的内容
    }
}
```
我们不用去直接创建锁和锁定对象，它会像其它互斥锁一样，防止其它线程获取同一个锁。传递给`@synchronized`的对象是区分保护块的唯一表示。

**实现原理：**编译器将`@synchronized`转化成了一对`objc_sync_enter`和`objc_sync_exit`的调用，通过查看[源码](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.mm)我们尝试分析得出几个结论：

1、 `@synchronized`是通过`recursive_mutex_t `递归锁实现；

2、 `@synchronized（nil）`起不到加锁的作用

```
// Begin synchronizing on 'obj'.
// Allocates recursive mutex associated with 'obj' if needed.
// Returns OBJC_SYNC_SUCCESS once lock is acquired.
int objc_sync_enter(id obj)
{
    int result = OBJC_SYNC_SUCCESS;
    
    if (obj) {
        SyncData* data = id2data(obj, ACQUIRE);
        require_action_string(data != NULL, done, result = OBJC_SYNC_NOT_INITIALIZED, "id2data failed");
        
        result = recursive_mutex_lock(&data->mutex);
        require_noerr_string(result, done, "mutex_lock failed");
    } else {
        // @synchronized(nil) does nothing
        if (DebugNilSync) {
            _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
        }
        objc_sync_nil();
    }
    
done:
    return result;
}

// End synchronizing on 'obj'.
// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR
int objc_sync_exit(id obj)
{
    int result = OBJC_SYNC_SUCCESS;
    
    if (obj) {
        SyncData* data = id2data(obj, RELEASE);
        require_action_string(data != NULL, done, result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR, "id2data failed");
        
        result = recursive_mutex_unlock(&data->mutex);
        require_noerr_string(result, done, "mutex_unlock failed");
    } else {
        // @synchronized(nil) does nothing 传入的对象为空，不起任何作用
    }
    
done:
    if ( result == RECURSIVE_MUTEX_NOT_LOCKED )
        result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
    
    return result;
}
```


